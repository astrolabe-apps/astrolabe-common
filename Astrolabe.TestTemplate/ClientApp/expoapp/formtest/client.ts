//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class DocumentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Submit a document
     * @param citizenID (optional) 
     * @param name (optional) 
     * @param type (optional) 
     * @param classification (optional) 
     * @param batchID (optional) 
     * @param retentionMonths (optional) 
     * @param deliveryDate (optional) 
     * @param isSecure (optional) 
     * @param isNotifiable (optional) 
     * @param subject (optional) 
     * @param priority (optional) 
     * @param body (optional) 
     * @param keywords (optional) 
     * @param sMSMessage (optional) 
     * @param file (optional) 
     */
    postDocument(citizenID: string | undefined, name: string | undefined, type: string | undefined, classification: string | undefined, batchID: string | undefined, retentionMonths: number | null | undefined, deliveryDate: string | null | undefined, isSecure: boolean | undefined, isNotifiable: boolean | undefined, subject: string | undefined, priority: string | undefined, body: string | undefined, keywords: string[] | undefined, sMSMessage: string | undefined, file: FileParameter | undefined): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/Document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (citizenID === null || citizenID === undefined)
            throw new Error("The parameter 'citizenID' cannot be null.");
        else
            content_.append("CitizenID", citizenID.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (classification === null || classification === undefined)
            throw new Error("The parameter 'classification' cannot be null.");
        else
            content_.append("Classification", classification.toString());
        if (batchID === null || batchID === undefined)
            throw new Error("The parameter 'batchID' cannot be null.");
        else
            content_.append("BatchID", batchID.toString());
        if (retentionMonths !== null && retentionMonths !== undefined)
            content_.append("RetentionMonths", retentionMonths.toString());
        if (deliveryDate !== null && deliveryDate !== undefined)
            content_.append("DeliveryDate", deliveryDate.toString());
        if (isSecure === null || isSecure === undefined)
            throw new Error("The parameter 'isSecure' cannot be null.");
        else
            content_.append("IsSecure", isSecure.toString());
        if (isNotifiable === null || isNotifiable === undefined)
            throw new Error("The parameter 'isNotifiable' cannot be null.");
        else
            content_.append("IsNotifiable", isNotifiable.toString());
        if (subject === null || subject === undefined)
            throw new Error("The parameter 'subject' cannot be null.");
        else
            content_.append("Subject", subject.toString());
        if (priority === null || priority === undefined)
            throw new Error("The parameter 'priority' cannot be null.");
        else
            content_.append("Priority", priority.toString());
        if (body === null || body === undefined)
            throw new Error("The parameter 'body' cannot be null.");
        else
            content_.append("Body", body.toString());
        if (keywords === null || keywords === undefined)
            throw new Error("The parameter 'keywords' cannot be null.");
        else
            keywords.forEach(item_ => content_.append("Keywords", item_.toString()));
        if (sMSMessage === null || sMSMessage === undefined)
            throw new Error("The parameter 'sMSMessage' cannot be null.");
        else
            content_.append("SMSMessage", sMSMessage.toString());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostDocument(_response);
        });
    }

    protected processPostDocument(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DocumentResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * Tests the markdown format of a message
     */
    testFormatMessage(message: TestMessageFormat): Promise<string> {
        let url_ = this.baseUrl + "/Document/testmarkdownformat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestFormatMessage(_response);
        });
    }

    protected processTestFormatMessage(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class MessageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Submit a message
     */
    postMessage(message: Message): Promise<MessageResponse> {
        let url_ = this.baseUrl + "/Message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMessage(_response);
        });
    }

    protected processPostMessage(response: Response): Promise<MessageResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MessageResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageResponse>(null as any);
    }

    getStatus(): Promise<boolean> {
        let url_ = this.baseUrl + "/Message/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class HealthCheckClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    mRSCheck(): Promise<string> {
        let url_ = this.baseUrl + "/HealthCheck/mrs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMRSCheck(_response);
        });
    }

    protected processMRSCheck(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    emailCheck(): Promise<EmailResult> {
        let url_ = this.baseUrl + "/HealthCheck/email";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmailCheck(_response);
        });
    }

    protected processEmailCheck(response: Response): Promise<EmailResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EmailResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmailResult>(null as any);
    }

    sMSCheck(): Promise<boolean> {
        let url_ = this.baseUrl + "/HealthCheck/sms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSMSCheck(_response);
        });
    }

    protected processSMSCheck(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    docStoreCheck(): Promise<boolean> {
        let url_ = this.baseUrl + "/HealthCheck/documents";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocStoreCheck(_response);
        });
    }

    protected processDocStoreCheck(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    dataverseCheck(serviceProvider: string): Promise<boolean> {
        let url_ = this.baseUrl + "/HealthCheck/dataverse/{serviceProvider}";
        if (serviceProvider === undefined || serviceProvider === null)
            throw new Error("The parameter 'serviceProvider' must be defined.");
        url_ = url_.replace("{serviceProvider}", encodeURIComponent("" + serviceProvider));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataverseCheck(_response);
        });
    }

    protected processDataverseCheck(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    databaseCheck(): Promise<boolean> {
        let url_ = this.baseUrl + "/HealthCheck/database";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDatabaseCheck(_response);
        });
    }

    protected processDatabaseCheck(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    serviceBusReadCheck(): Promise<number> {
        let url_ = this.baseUrl + "/HealthCheck/servicebus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processServiceBusReadCheck(_response);
        });
    }

    protected processServiceBusReadCheck(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    pubSubCheck(): Promise<string> {
        let url_ = this.baseUrl + "/HealthCheck/pubsub";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPubSubCheck(_response);
        });
    }

    protected processPubSubCheck(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    redisCheck(): Promise<string> {
        let url_ = this.baseUrl + "/HealthCheck/redis";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRedisCheck(_response);
        });
    }

    protected processRedisCheck(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    dVSCheck(): Promise<string> {
        let url_ = this.baseUrl + "/HealthCheck/dvs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDVSCheck(_response);
        });
    }

    protected processDVSCheck(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    fullAppVersion(): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/HealthCheck/apifullversion";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFullAppVersion(_response);
        });
    }

    protected processFullAppVersion(response: Response): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: string; };
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string; }>(null as any);
    }

    getApiVersion(): Promise<string> {
        let url_ = this.baseUrl + "/HealthCheck/apiversion";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiVersion(_response);
        });
    }

    protected processGetApiVersion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getSystemVersionInformation(): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/HealthCheck/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSystemVersionInformation(_response);
        });
    }

    protected processGetSystemVersionInformation(response: Response): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: string; };
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string; }>(null as any);
    }
}

export class InternalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    inRange(startRange: string | undefined, endRange: string | null | undefined, start: string | undefined, end: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Internal/testDateRange?";
        if (startRange === null)
            throw new Error("The parameter 'startRange' cannot be null.");
        else if (startRange !== undefined)
            url_ += "startRange=" + encodeURIComponent("" + startRange) + "&";
        if (endRange !== undefined && endRange !== null)
            url_ += "endRange=" + encodeURIComponent("" + endRange) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInRange(_response);
        });
    }

    protected processInRange(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getMessages(): Promise<ViewMessage[]> {
        let url_ = this.baseUrl + "/Internal/messages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMessages(_response);
        });
    }

    protected processGetMessages(response: Response): Promise<ViewMessage[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ViewMessage[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ViewMessage[]>(null as any);
    }

    getVerifiedDocuments(): Promise<ViewVerifiedDocument[]> {
        let url_ = this.baseUrl + "/Internal/verifieddocuments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVerifiedDocuments(_response);
        });
    }

    protected processGetVerifiedDocuments(response: Response): Promise<ViewVerifiedDocument[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ViewVerifiedDocument[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ViewVerifiedDocument[]>(null as any);
    }

    getDocuments(): Promise<ViewDocument[]> {
        let url_ = this.baseUrl + "/Internal/documents";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDocuments(_response);
        });
    }

    protected processGetDocuments(response: Response): Promise<ViewDocument[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ViewDocument[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ViewDocument[]>(null as any);
    }

    ensureContact(createContact: boolean): Promise<InternalContactDetails> {
        let url_ = this.baseUrl + "/Internal/ensureContact/{createContact}";
        if (createContact === undefined || createContact === null)
            throw new Error("The parameter 'createContact' must be defined.");
        url_ = url_.replace("{createContact}", encodeURIComponent("" + createContact));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnsureContact(_response);
        });
    }

    protected processEnsureContact(response: Response): Promise<InternalContactDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InternalContactDetails;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InternalContactDetails>(null as any);
    }

    updateAddressDetails(strucutredAddress: boolean | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Internal?";
        if (strucutredAddress === null)
            throw new Error("The parameter 'strucutredAddress' cannot be null.");
        else if (strucutredAddress !== undefined)
            url_ += "strucutredAddress=" + encodeURIComponent("" + strucutredAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAddressDetails(_response);
        });
    }

    protected processUpdateAddressDetails(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getCitizensForImpersonsation(): Promise<CitizenDetails[]> {
        let url_ = this.baseUrl + "/Internal/citizensforimpersonation";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCitizensForImpersonsation(_response);
        });
    }

    protected processGetCitizensForImpersonsation(response: Response): Promise<CitizenDetails[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CitizenDetails[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CitizenDetails[]>(null as any);
    }

    reLinkOnMRS(clientId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/Internal/relink/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReLinkOnMRS(_response);
        });
    }

    protected processReLinkOnMRS(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    createImpersonationRecord(record: ImpersonateRecord): Promise<boolean> {
        let url_ = this.baseUrl + "/Internal/createimpersonsate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateImpersonationRecord(_response);
        });
    }

    protected processCreateImpersonationRecord(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getForms(): Promise<string> {
        let url_ = this.baseUrl + "/Internal/forms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetForms(_response);
        });
    }

    protected processGetForms(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    schemas(): Promise<string> {
        let url_ = this.baseUrl + "/Internal/schemas";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSchemas(_response);
        });
    }

    protected processSchemas(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    editForm(id: string, formData: any): Promise<void> {
        let url_ = this.baseUrl + "/Internal/form/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(formData);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditForm(_response);
        });
    }

    protected processEditForm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    startGrain(seconds: number | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Internal/testGrain?";
        if (seconds !== undefined && seconds !== null)
            url_ += "seconds=" + encodeURIComponent("" + seconds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartGrain(_response);
        });
    }

    protected processStartGrain(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    pls(): Promise<ExtraTypes> {
        let url_ = this.baseUrl + "/Internal/forTypesOnly";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPls(_response);
        });
    }

    protected processPls(response: Response): Promise<ExtraTypes> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExtraTypes;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExtraTypes>(null as any);
    }

    checkMrsPayment(): Promise<void> {
        let url_ = this.baseUrl + "/Internal/CheckMrsPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckMrsPayment(_response);
        });
    }

    protected processCheckMrsPayment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    testUpdatePayment(): Promise<void> {
        let url_ = this.baseUrl + "/Internal/UpdatePayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestUpdatePayment(_response);
        });
    }

    protected processTestUpdatePayment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MrsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Link via Licence
     */
    clientLinkLicence(link: ClientLinkLicence): Promise<LinkLicenceResponse> {
        let url_ = this.baseUrl + "/Mrs/clientlink/licence";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(link);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientLinkLicence(_response);
        });
    }

    protected processClientLinkLicence(response: Response): Promise<LinkLicenceResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LinkLicenceResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkLicenceResponse>(null as any);
    }

    checkMRSName(): Promise<boolean> {
        let url_ = this.baseUrl + "/Mrs/checkname";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckMRSName(_response);
        });
    }

    protected processCheckMRSName(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    recheckMRSName(id: string): Promise<NameMatchResponse> {
        let url_ = this.baseUrl + "/Mrs/recheckname/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecheckMRSName(_response);
        });
    }

    protected processRecheckMRSName(response: Response): Promise<NameMatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NameMatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NameMatchResponse>(null as any);
    }

    /**
     * Link via Registration
     */
    clientLinkRegistration(link: ClientLinkRegistration): Promise<boolean> {
        let url_ = this.baseUrl + "/Mrs/clientlink/registration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(link);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientLinkRegistration(_response);
        });
    }

    protected processClientLinkRegistration(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Unlink MRS Account
     */
    unlinkClient(): Promise<boolean> {
        let url_ = this.baseUrl + "/Mrs/unlink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnlinkClient(_response);
        });
    }

    protected processUnlinkClient(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Client Summary
     */
    clientSummary(requery: boolean, demeritDetails: boolean): Promise<MRSClientSummary> {
        let url_ = this.baseUrl + "/Mrs/clientsummary/{requery}/{demeritDetails}";
        if (requery === undefined || requery === null)
            throw new Error("The parameter 'requery' must be defined.");
        url_ = url_.replace("{requery}", encodeURIComponent("" + requery));
        if (demeritDetails === undefined || demeritDetails === null)
            throw new Error("The parameter 'demeritDetails' must be defined.");
        url_ = url_.replace("{demeritDetails}", encodeURIComponent("" + demeritDetails));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientSummary(_response);
        });
    }

    protected processClientSummary(response: Response): Promise<MRSClientSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSClientSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSClientSummary>(null as any);
    }

    /**
     * Licence Details
     */
    getLicenseDetails(requery: boolean): Promise<LicenceDetail> {
        let url_ = this.baseUrl + "/Mrs/license/details/{requery}";
        if (requery === undefined || requery === null)
            throw new Error("The parameter 'requery' must be defined.");
        url_ = url_.replace("{requery}", encodeURIComponent("" + requery));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLicenseDetails(_response);
        });
    }

    protected processGetLicenseDetails(response: Response): Promise<LicenceDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LicenceDetail;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LicenceDetail>(null as any);
    }

    /**
     * Licence History
     */
    requestLicenceHistory(): Promise<boolean> {
        let url_ = this.baseUrl + "/Mrs/licence/history";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestLicenceHistory(_response);
        });
    }

    protected processRequestLicenceHistory(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Licence Renewal Quote
     */
    getRenewalQuote(renewLearner: boolean): Promise<MRSLicenceRenewalQuote> {
        let url_ = this.baseUrl + "/Mrs/licence/renewalquote/{renewLearner}";
        if (renewLearner === undefined || renewLearner === null)
            throw new Error("The parameter 'renewLearner' must be defined.");
        url_ = url_.replace("{renewLearner}", encodeURIComponent("" + renewLearner));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRenewalQuote(_response);
        });
    }

    protected processGetRenewalQuote(response: Response): Promise<MRSLicenceRenewalQuote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSLicenceRenewalQuote;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSLicenceRenewalQuote>(null as any);
    }

    /**
     * Licence Renewal Confirmation
     */
    renewLicence(request: MRSLicenceRenewalRequest): Promise<MRSConfirmationResponse> {
        let url_ = this.baseUrl + "/Mrs/licence/renew";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenewLicence(_response);
        });
    }

    protected processRenewLicence(response: Response): Promise<MRSConfirmationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSConfirmationResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            let result405: any = null;
            result405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result405);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSConfirmationResponse>(null as any);
    }

    /**
     * Update MRS Postal Address
     */
    updatePostalMRSAddress(address: Address): Promise<boolean> {
        let url_ = this.baseUrl + "/Mrs/licence/updatepostaladdress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(address);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePostalMRSAddress(_response);
        });
    }

    protected processUpdatePostalMRSAddress(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Registration(s) Summary EndPoint
     */
    getRegistrationSummary(page: number, pageSize: number): Promise<MRSPagingRegistrationSummary> {
        let url_ = this.baseUrl + "/Mrs/registrations/{page}/{pageSize}";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined.");
        url_ = url_.replace("{page}", encodeURIComponent("" + page));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegistrationSummary(_response);
        });
    }

    protected processGetRegistrationSummary(response: Response): Promise<MRSPagingRegistrationSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSPagingRegistrationSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSPagingRegistrationSummary>(null as any);
    }

    /**
     * Preload Registrations
     */
    loadAllRegistrationsForUser(): Promise<void> {
        let url_ = this.baseUrl + "/Mrs/registrations/load";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoadAllRegistrationsForUser(_response);
        });
    }

    protected processLoadAllRegistrationsForUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Registration List EndPoint
     */
    listRegistrationSummaries(search: MRSRegistrationSearch): Promise<MRSPagingRegistrationSummary> {
        let url_ = this.baseUrl + "/Mrs/registrations/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(search);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListRegistrationSummaries(_response);
        });
    }

    protected processListRegistrationSummaries(response: Response): Promise<MRSPagingRegistrationSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSPagingRegistrationSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSPagingRegistrationSummary>(null as any);
    }

    /**
     * Registration Detail
     */
    getRegistrationDetails(id: number, requery: boolean): Promise<RegistrationDetail> {
        let url_ = this.baseUrl + "/Mrs/registration/{id}/{requery}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (requery === undefined || requery === null)
            throw new Error("The parameter 'requery' must be defined.");
        url_ = url_.replace("{requery}", encodeURIComponent("" + requery));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegistrationDetails(_response);
        });
    }

    protected processGetRegistrationDetails(response: Response): Promise<RegistrationDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationDetail;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegistrationDetail>(null as any);
    }

    /**
     * Registration Renewal Quote
     */
    getRegistrationRenewalQuote(id: number): Promise<RegistrationRenewalQuote> {
        let url_ = this.baseUrl + "/Mrs/registration/renewalquote/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegistrationRenewalQuote(_response);
        });
    }

    protected processGetRegistrationRenewalQuote(response: Response): Promise<RegistrationRenewalQuote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationRenewalQuote;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegistrationRenewalQuote>(null as any);
    }

    /**
     * Registration Renewal Confirmation
     */
    renewRegistration(id: number, request: MRSRegistrationRenewalRequest): Promise<MRSConfirmationResponse> {
        let url_ = this.baseUrl + "/Mrs/registration/renew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenewRegistration(_response);
        });
    }

    protected processRenewRegistration(response: Response): Promise<MRSConfirmationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSConfirmationResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSConfirmationResponse>(null as any);
    }

    /**
     * Registration Renewal Certificate
     */
    requestCertificate(id: number): Promise<boolean> {
        let url_ = this.baseUrl + "/Mrs/registration/certificate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestCertificate(_response);
        });
    }

    protected processRequestCertificate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Additional Plate Quote
     */
    quotePlates(id: number, testData: boolean): Promise<PlatesOrderQuote> {
        let url_ = this.baseUrl + "/Mrs/registration/plates/quote/{id}/{testData}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testData === undefined || testData === null)
            throw new Error("The parameter 'testData' must be defined.");
        url_ = url_.replace("{testData}", encodeURIComponent("" + testData));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuotePlates(_response);
        });
    }

    protected processQuotePlates(response: Response): Promise<PlatesOrderQuote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlatesOrderQuote;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlatesOrderQuote>(null as any);
    }

    /**
     * Additional Plate Order Confirmation
     */
    orderPlates(id: number, testData: boolean, paymentDetails: MRSPaymentDetails): Promise<string> {
        let url_ = this.baseUrl + "/Mrs/registration/plates/order/{id}/{testData}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testData === undefined || testData === null)
            throw new Error("The parameter 'testData' must be defined.");
        url_ = url_.replace("{testData}", encodeURIComponent("" + testData));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderPlates(_response);
        });
    }

    protected processOrderPlates(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Create Client
     */
    createClient(client: MRSCreateClient): Promise<string> {
        let url_ = this.baseUrl + "/Mrs/client/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(client);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateClient(_response);
        });
    }

    protected processCreateClient(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getMRSAddress(): Promise<MRSCompareAddress> {
        let url_ = this.baseUrl + "/Mrs/client/address";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMRSAddress(_response);
        });
    }

    protected processGetMRSAddress(response: Response): Promise<MRSCompareAddress> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSCompareAddress;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSCompareAddress>(null as any);
    }

    updateMRSAddress(addressUpdate: MRSUpdateAddress): Promise<MRSAddressUpdateResult> {
        let url_ = this.baseUrl + "/Mrs/client/address";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addressUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMRSAddress(_response);
        });
    }

    protected processUpdateMRSAddress(response: Response): Promise<MRSAddressUpdateResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSAddressUpdateResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSAddressUpdateResult>(null as any);
    }

    /**
     * Client IP Address
     */
    getClientIPAddress(): Promise<string> {
        let url_ = this.baseUrl + "/Mrs/ipaddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetClientIPAddress(_response);
        });
    }

    protected processGetClientIPAddress(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * TUP Vehicle Lookup
     */
    tUPLookup(lookup: MRSTUPVehicleLookup): Promise<MRSTUPLookupResponse> {
        let url_ = this.baseUrl + "/Mrs/registration/tup/lookup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lookup);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTUPLookup(_response);
        });
    }

    protected processTUPLookup(response: Response): Promise<MRSTUPLookupResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSTUPLookupResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSTUPLookupResponse>(null as any);
    }

    getTUPDetail(registrationId: number | undefined, ownVehicle: boolean | undefined, plateNumber: string | null | undefined, make: string | null | undefined, model: string | null | undefined, colour: string | null | undefined): Promise<TUPsForm> {
        let url_ = this.baseUrl + "/Mrs/registration/tup/detail?";
        if (registrationId === null)
            throw new Error("The parameter 'registrationId' cannot be null.");
        else if (registrationId !== undefined)
            url_ += "RegistrationId=" + encodeURIComponent("" + registrationId) + "&";
        if (ownVehicle === null)
            throw new Error("The parameter 'ownVehicle' cannot be null.");
        else if (ownVehicle !== undefined)
            url_ += "OwnVehicle=" + encodeURIComponent("" + ownVehicle) + "&";
        if (plateNumber !== undefined && plateNumber !== null)
            url_ += "PlateNumber=" + encodeURIComponent("" + plateNumber) + "&";
        if (make !== undefined && make !== null)
            url_ += "Make=" + encodeURIComponent("" + make) + "&";
        if (model !== undefined && model !== null)
            url_ += "Model=" + encodeURIComponent("" + model) + "&";
        if (colour !== undefined && colour !== null)
            url_ += "Colour=" + encodeURIComponent("" + colour) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTUPDetail(_response);
        });
    }

    protected processGetTUPDetail(response: Response): Promise<TUPsForm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUPsForm;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUPsForm>(null as any);
    }

    getTUPQuote(quote: TUPQuote): Promise<TUPQuoteResponse> {
        let url_ = this.baseUrl + "/Mrs/registration/tup/quote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(quote);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTUPQuote(_response);
        });
    }

    protected processGetTUPQuote(response: Response): Promise<TUPQuoteResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUPQuoteResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUPQuoteResponse>(null as any);
    }

    tUPPayment(request: TUPPaymentRequest): Promise<TUPPaymentResponse> {
        let url_ = this.baseUrl + "/Mrs/registration/tup/payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTUPPayment(_response);
        });
    }

    protected processTUPPayment(response: Response): Promise<TUPPaymentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUPPaymentResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUPPaymentResponse>(null as any);
    }

    confirmTUP(confirmationRequest: TUPConfirmationRequest): Promise<string> {
        let url_ = this.baseUrl + "/Mrs/registration/tup/confirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(confirmationRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmTUP(_response);
        });
    }

    protected processConfirmTUP(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    saveTUP(submit: boolean | undefined, id: string | null | undefined, tup: CreateTUPRequest): Promise<string> {
        let url_ = this.baseUrl + "/Mrs/registration/tup?";
        if (submit === null)
            throw new Error("The parameter 'submit' cannot be null.");
        else if (submit !== undefined)
            url_ += "submit=" + encodeURIComponent("" + submit) + "&";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tup);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveTUP(_response);
        });
    }

    protected processSaveTUP(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getTUPSummary(offset: number | null | undefined, length: number | null | undefined, orderBy: string | null | undefined, includeCount: boolean | null | undefined): Promise<TUPSummary[]> {
        let url_ = this.baseUrl + "/Mrs/registration/tup?";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (length !== undefined && length !== null)
            url_ += "Length=" + encodeURIComponent("" + length) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (includeCount !== undefined && includeCount !== null)
            url_ += "IncludeCount=" + encodeURIComponent("" + includeCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTUPSummary(_response);
        });
    }

    protected processGetTUPSummary(response: Response): Promise<TUPSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUPSummary[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUPSummary[]>(null as any);
    }

    getTUPEdit(tupId: string): Promise<TUPsForm> {
        let url_ = this.baseUrl + "/Mrs/registration/tup/{tupId}";
        if (tupId === undefined || tupId === null)
            throw new Error("The parameter 'tupId' must be defined.");
        url_ = url_.replace("{tupId}", encodeURIComponent("" + tupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTUPEdit(_response);
        });
    }

    protected processGetTUPEdit(response: Response): Promise<TUPsForm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUPsForm;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUPsForm>(null as any);
    }

    /**
     * STP Vehicle Lookup
     */
    sTPLookup(lookup: MRSVehicleLookup): Promise<MRSSTPLookupResponse> {
        let url_ = this.baseUrl + "/Mrs/registration/stp/lookup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lookup);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSTPLookup(_response);
        });
    }

    protected processSTPLookup(response: Response): Promise<MRSSTPLookupResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSSTPLookupResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSSTPLookupResponse>(null as any);
    }

    /**
     * STP Quote
     */
    quoteShortTermPermit(stpQuote: MRSShortTermRegistrationQuote): Promise<ShortTermRegistrationQuoteResponse> {
        let url_ = this.baseUrl + "/Mrs/registration/stp/quote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stpQuote);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuoteShortTermPermit(_response);
        });
    }

    protected processQuoteShortTermPermit(response: Response): Promise<ShortTermRegistrationQuoteResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortTermRegistrationQuoteResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShortTermRegistrationQuoteResponse>(null as any);
    }

    /**
     * STP Known Confirmation
     */
    confirmShortTermPermit(stpDetails: MRSShortTermRegistrationPermitConfirmation): Promise<MRSConfirmationResponse> {
        let url_ = this.baseUrl + "/Mrs/registration/stp/confirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stpDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmShortTermPermit(_response);
        });
    }

    protected processConfirmShortTermPermit(response: Response): Promise<MRSConfirmationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSConfirmationResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSConfirmationResponse>(null as any);
    }

    /**
     * STP Unknown Confirmation
     */
    confirmUnknownShortTermPermit(stpDetails: MRSUnknownShortTermRegistrationPermitConfirmation): Promise<MRSConfirmationResponse> {
        let url_ = this.baseUrl + "/Mrs/registration/stp/unknown/confirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stpDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmUnknownShortTermPermit(_response);
        });
    }

    protected processConfirmUnknownShortTermPermit(response: Response): Promise<MRSConfirmationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSConfirmationResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSConfirmationResponse>(null as any);
    }

    getMRSReceipt(id: string): Promise<string> {
        let url_ = this.baseUrl + "/Mrs/receipt/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMRSReceipt(_response);
        });
    }

    protected processGetMRSReceipt(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getMRSClientRegistrations(): Promise<MRSRegistrationLookup[]> {
        let url_ = this.baseUrl + "/Mrs/CurrentRegistrations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMRSClientRegistrations(_response);
        });
    }

    protected processGetMRSClientRegistrations(response: Response): Promise<MRSRegistrationLookup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSRegistrationLookup[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSRegistrationLookup[]>(null as any);
    }
}

export class MrsStaffClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Link Client
     */
    forceClientLink(citizenId: string, clientId: number): Promise<void> {
        let url_ = this.baseUrl + "/MrsStaff/forceclientlink/{citizenId}/{clientId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForceClientLink(_response);
        });
    }

    protected processForceClientLink(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Link Citizen via Licence
     */
    clientLinkLicence(citizenId: string, link: ClientLinkLicence): Promise<boolean> {
        let url_ = this.baseUrl + "/MrsStaff/clientlink/{citizenId}/licence";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(link);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientLinkLicence(_response);
        });
    }

    protected processClientLinkLicence(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Link Citizen via Registration
     */
    clientLinkRegistration(citizenId: string, link: ClientLinkRegistration): Promise<boolean> {
        let url_ = this.baseUrl + "/MrsStaff/clientlink/{citizenId}/registration";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(link);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientLinkRegistration(_response);
        });
    }

    protected processClientLinkRegistration(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Unlink MRS Client
     */
    unlinkClient(citizenId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/MrsStaff/unlinkclient/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnlinkClient(_response);
        });
    }

    protected processUnlinkClient(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Client Summary
     */
    clientSummary(citizenId: string): Promise<MRSClientSummary> {
        let url_ = this.baseUrl + "/MrsStaff/clientsummary/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClientSummary(_response);
        });
    }

    protected processClientSummary(response: Response): Promise<MRSClientSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSClientSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSClientSummary>(null as any);
    }

    /**
     * Licence Detais
     */
    getLicenceDetails(citizenId: string): Promise<LicenceDetail> {
        let url_ = this.baseUrl + "/MrsStaff/licencedetails/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLicenceDetails(_response);
        });
    }

    protected processGetLicenceDetails(response: Response): Promise<LicenceDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LicenceDetail;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LicenceDetail>(null as any);
    }

    /**
     * Renew Licence Quote
     */
    getRenewalQuote(citizenId: string, renewLearner: boolean): Promise<MRSLicenceRenewalQuote> {
        let url_ = this.baseUrl + "/MrsStaff/renewalquote/{citizenId}/{renewLearner}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (renewLearner === undefined || renewLearner === null)
            throw new Error("The parameter 'renewLearner' must be defined.");
        url_ = url_.replace("{renewLearner}", encodeURIComponent("" + renewLearner));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRenewalQuote(_response);
        });
    }

    protected processGetRenewalQuote(response: Response): Promise<MRSLicenceRenewalQuote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSLicenceRenewalQuote;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSLicenceRenewalQuote>(null as any);
    }

    /**
     * Renew Licence
     */
    renewLicence(citizenId: string, request: MRSLicenceRenewalRequest): Promise<string> {
        let url_ = this.baseUrl + "/MrsStaff/renewlicence/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenewLicence(_response);
        });
    }

    protected processRenewLicence(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Licence History
     */
    requestLicenceHistory(citizenId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/MrsStaff/licencehistory/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestLicenceHistory(_response);
        });
    }

    protected processRequestLicenceHistory(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Registrations
     */
    getRegistrationSummary(citizenId: string): Promise<MRSPagingRegistrationSummary> {
        let url_ = this.baseUrl + "/MrsStaff/registrations/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegistrationSummary(_response);
        });
    }

    protected processGetRegistrationSummary(response: Response): Promise<MRSPagingRegistrationSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSPagingRegistrationSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSPagingRegistrationSummary>(null as any);
    }

    /**
     * Registration
     */
    getRegistrationDetails(citizenId: string, id: number): Promise<RegistrationDetail> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/{id}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegistrationDetails(_response);
        });
    }

    protected processGetRegistrationDetails(response: Response): Promise<RegistrationDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationDetail;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegistrationDetail>(null as any);
    }

    /**
     * Registration Renewal Quote
     */
    getRegistrationRenewalQuote(citizenId: string, id: number): Promise<RegistrationRenewalQuote> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/renewalquote/{id}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegistrationRenewalQuote(_response);
        });
    }

    protected processGetRegistrationRenewalQuote(response: Response): Promise<RegistrationRenewalQuote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationRenewalQuote;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegistrationRenewalQuote>(null as any);
    }

    /**
     * Registration Renewal Confirmation
     */
    renewRegistration(citizenId: string, id: number, request: MRSRegistrationRenewalRequest): Promise<string> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/renew/{id}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenewRegistration(_response);
        });
    }

    protected processRenewRegistration(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Registration Renewal Certificate
     */
    requestCertificate(citizenId: string, id: number): Promise<boolean> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/certificate/{id}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestCertificate(_response);
        });
    }

    protected processRequestCertificate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Additional Plate Quote
     */
    quotePlates(citizenId: string, id: number, testData: string): Promise<PlatesOrderQuote> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/plates/quote/{id}/{testData}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testData === undefined || testData === null)
            throw new Error("The parameter 'testData' must be defined.");
        url_ = url_.replace("{testData}", encodeURIComponent("" + testData));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuotePlates(_response);
        });
    }

    protected processQuotePlates(response: Response): Promise<PlatesOrderQuote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlatesOrderQuote;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlatesOrderQuote>(null as any);
    }

    /**
     * Additional Plate Order Confirmation
     */
    orderPlates(citizenId: string, id: number, testData: boolean, paymentDetails: MRSPaymentDetails): Promise<string> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/plates/order/{id}/{testData}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testData === undefined || testData === null)
            throw new Error("The parameter 'testData' must be defined.");
        url_ = url_.replace("{testData}", encodeURIComponent("" + testData));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderPlates(_response);
        });
    }

    protected processOrderPlates(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * STP Vehicle Lookup
     */
    sTPLookup(lookup: MRSVehicleLookup): Promise<MRSSTPLookupResponse> {
        let url_ = this.baseUrl + "/MrsStaff/registration/stp/lookup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lookup);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSTPLookup(_response);
        });
    }

    protected processSTPLookup(response: Response): Promise<MRSSTPLookupResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSSTPLookupResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSSTPLookupResponse>(null as any);
    }

    loadSTPLookupData(): Promise<void> {
        let url_ = this.baseUrl + "/MrsStaff";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoadSTPLookupData(_response);
        });
    }

    protected processLoadSTPLookupData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * STP Quote
     */
    quoteShortTermPermit(citizenId: string, stpQuote: MRSShortTermRegistrationQuote): Promise<ShortTermRegistrationQuoteResponse> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/stp/quote";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stpQuote);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuoteShortTermPermit(_response);
        });
    }

    protected processQuoteShortTermPermit(response: Response): Promise<ShortTermRegistrationQuoteResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortTermRegistrationQuoteResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShortTermRegistrationQuoteResponse>(null as any);
    }

    confirmShortTermPermit(citizenId: string, stpDetails: MRSShortTermRegistrationPermitConfirmation): Promise<string> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/stp/confirm";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stpDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmShortTermPermit(_response);
        });
    }

    protected processConfirmShortTermPermit(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    confirmUnknownShortTermPermit(citizenId: string, stpDetails: MRSUnknownShortTermRegistrationPermitConfirmation): Promise<string> {
        let url_ = this.baseUrl + "/MrsStaff/registration/{citizenId}/stp/unknown/confirm";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stpDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmUnknownShortTermPermit(_response);
        });
    }

    protected processConfirmUnknownShortTermPermit(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Client IP Address
     */
    createClient(citizenId: string, client: MRSCreateClient): Promise<string> {
        let url_ = this.baseUrl + "/MrsStaff/client/create/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(client);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateClient(_response);
        });
    }

    protected processCreateClient(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * MRS Version
     */
    getMrsVersion(): Promise<string> {
        let url_ = this.baseUrl + "/MrsStaff/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMrsVersion(_response);
        });
    }

    protected processGetMrsVersion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Client IP Address
     */
    getClientIPAddress(): Promise<string> {
        let url_ = this.baseUrl + "/MrsStaff/ipaddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetClientIPAddress(_response);
        });
    }

    protected processGetClientIPAddress(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getMRSAddress(citizenId: string): Promise<MRSCompareAddress> {
        let url_ = this.baseUrl + "/MrsStaff/client/address/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMRSAddress(_response);
        });
    }

    protected processGetMRSAddress(response: Response): Promise<MRSCompareAddress> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSCompareAddress;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSCompareAddress>(null as any);
    }

    updateMRSAddress(citizenId: string, addressUpdate: MRSUpdateAddress): Promise<MRSAddressUpdateResult> {
        let url_ = this.baseUrl + "/MrsStaff/client/address/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addressUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMRSAddress(_response);
        });
    }

    protected processUpdateMRSAddress(response: Response): Promise<MRSAddressUpdateResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MRSAddressUpdateResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MRSAddressUpdateResult>(null as any);
    }
}

export class PortalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Retrieve Document URI
     */
    getDocumentUrl(id: string, inline: boolean): Promise<string> {
        let url_ = this.baseUrl + "/Portal/document/{id}/{inline}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (inline === undefined || inline === null)
            throw new Error("The parameter 'inline' must be defined.");
        url_ = url_.replace("{inline}", encodeURIComponent("" + inline));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDocumentUrl(_response);
        });
    }

    protected processGetDocumentUrl(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    checkMobile(claims: { [key: string]: any; }): Promise<B2CError> {
        let url_ = this.baseUrl + "/Portal/checkMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(claims);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckMobile(_response);
        });
    }

    protected processCheckMobile(response: Response): Promise<B2CError> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as B2CError;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<B2CError>(null as any);
    }

    checkAccess(claims: { [key: string]: any; }): Promise<B2CError> {
        let url_ = this.baseUrl + "/Portal/checkAccess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(claims);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckAccess(_response);
        });
    }

    protected processCheckAccess(response: Response): Promise<B2CError> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as B2CError;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<B2CError>(null as any);
    }

    getFormStrings(page: PortalPage): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/Portal/snippets/{page}";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined.");
        url_ = url_.replace("{page}", encodeURIComponent("" + page));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormStrings(_response);
        });
    }

    protected processGetFormStrings(response: Response): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: string; };
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string; }>(null as any);
    }

    getContentSnippet(name: string): Promise<string> {
        let url_ = this.baseUrl + "/Portal/contentsnippet/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContentSnippet(_response);
        });
    }

    protected processGetContentSnippet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getMyDetails(): Promise<MyContactDetails> {
        let url_ = this.baseUrl + "/Portal/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyDetails(_response);
        });
    }

    protected processGetMyDetails(response: Response): Promise<MyContactDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MyContactDetails;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MyContactDetails>(null as any);
    }
}

export class StaffPortalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Retrieve Document URI
     */
    getDocumentUrl(id: string, inline: boolean): Promise<string> {
        let url_ = this.baseUrl + "/StaffPortal/document/{id}/{inline}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (inline === undefined || inline === null)
            throw new Error("The parameter 'inline' must be defined.");
        url_ = url_.replace("{inline}", encodeURIComponent("" + inline));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDocumentUrl(_response);
        });
    }

    protected processGetDocumentUrl(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Upload Document
     * @param file (optional) 
     */
    uploadDocument(documentId: string, file: FileParameter | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/StaffPortal/document/{documentId}";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadDocument(_response);
        });
    }

    protected processUploadDocument(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    clearCache(): Promise<void> {
        let url_ = this.baseUrl + "/StaffPortal/clearconfigurationcache";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearCache(_response);
        });
    }

    protected processClearCache(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    clearCache2(citizenId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/StaffPortal/clearcache/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearCache2(_response);
        });
    }

    protected processClearCache2(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class STInternalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    approveTUORequest(citizenId: string): Promise<number> {
        let url_ = this.baseUrl + "/STInternal/approvetuo/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveTUORequest(_response);
        });
    }

    protected processApproveTUORequest(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class TfsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    linkClient(): Promise<void> {
        let url_ = this.baseUrl + "/Tfs/clientlink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLinkClient(_response);
        });
    }

    protected processLinkClient(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unlinkClient(): Promise<void> {
        let url_ = this.baseUrl + "/Tfs/unlink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnlinkClient(_response);
        });
    }

    protected processUnlinkClient(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    listFireRegistrations(offset: number | null | undefined, length: number | null | undefined, orderBy: string | null | undefined, includeCount: boolean | null | undefined, type: Itg_typeoffireform | undefined): Promise<SearchResultsOfFirePermitSummary> {
        let url_ = this.baseUrl + "/Tfs/fireRegistration?";
        if (offset !== undefined && offset !== null)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (length !== undefined && length !== null)
            url_ += "Length=" + encodeURIComponent("" + length) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (includeCount !== undefined && includeCount !== null)
            url_ += "IncludeCount=" + encodeURIComponent("" + includeCount) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListFireRegistrations(_response);
        });
    }

    protected processListFireRegistrations(response: Response): Promise<SearchResultsOfFirePermitSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SearchResultsOfFirePermitSummary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResultsOfFirePermitSummary>(null as any);
    }

    createFireRegistration(submit: boolean | undefined, registration: InitialFireRegistration): Promise<string> {
        let url_ = this.baseUrl + "/Tfs/fireRegistration?";
        if (submit === null)
            throw new Error("The parameter 'submit' cannot be null.");
        else if (submit !== undefined)
            url_ += "submit=" + encodeURIComponent("" + submit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registration);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFireRegistration(_response);
        });
    }

    protected processCreateFireRegistration(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getFireRegistration(id: string): Promise<FireRegistrationAndLocation> {
        let url_ = this.baseUrl + "/Tfs/fireRegistration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFireRegistration(_response);
        });
    }

    protected processGetFireRegistration(response: Response): Promise<FireRegistrationAndLocation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FireRegistrationAndLocation;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FireRegistrationAndLocation>(null as any);
    }

    updateFireRegistration(id: string, submit: boolean | undefined, edit: FireRegistration): Promise<void> {
        let url_ = this.baseUrl + "/Tfs/fireRegistration/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (submit === null)
            throw new Error("The parameter 'submit' cannot be null.");
        else if (submit !== undefined)
            url_ += "submit=" + encodeURIComponent("" + submit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(edit);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFireRegistration(_response);
        });
    }

    protected processUpdateFireRegistration(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getReceipt(id: string): Promise<ReceiptConfirmation> {
        let url_ = this.baseUrl + "/Tfs/fireRegistration/{id}/receipt";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReceipt(_response);
        });
    }

    protected processGetReceipt(response: Response): Promise<ReceiptConfirmation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ReceiptConfirmation;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReceiptConfirmation>(null as any);
    }

    hasLinkedService(): Promise<boolean> {
        let url_ = this.baseUrl + "/Tfs/linkedservice";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHasLinkedService(_response);
        });
    }

    protected processHasLinkedService(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getFormStrings(): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/Tfs/snippets";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormStrings(_response);
        });
    }

    protected processGetFormStrings(response: Response): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: string; };
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string; }>(null as any);
    }

    getPermitsAndBans(): Promise<FireDates[]> {
        let url_ = this.baseUrl + "/Tfs/permitsandbans";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermitsAndBans(_response);
        });
    }

    protected processGetPermitsAndBans(response: Response): Promise<FireDates[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FireDates[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FireDates[]>(null as any);
    }

    logInitialOutcome(type: InitialFireOutcomeType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tfs/loginitialoutcome?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogInitialOutcome(_response);
        });
    }

    protected processLogInitialOutcome(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TUOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Generate Web Pub Client URI
     */
    getPubSubClientUri(): Promise<string> {
        let url_ = this.baseUrl + "/TUO/getPubSubUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPubSubClientUri(_response);
        });
    }

    protected processGetPubSubClientUri(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get Citizen ID by details
     */
    getCitizenIdByDetails(details: CitizenLookupDetails): Promise<string> {
        let url_ = this.baseUrl + "/TUO/citizenidbydetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(details);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCitizenIdByDetails(_response);
        });
    }

    protected processGetCitizenIdByDetails(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get Citizen Details by Search Details
     */
    searchCitizensByDetails(details: CitizenLookupDetails): Promise<TUOCitizenLookupResult[]> {
        let url_ = this.baseUrl + "/TUO/searchcitizenbydetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(details);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchCitizensByDetails(_response);
        });
    }

    protected processSearchCitizensByDetails(response: Response): Promise<TUOCitizenLookupResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUOCitizenLookupResult[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUOCitizenLookupResult[]>(null as any);
    }

    /**
     * Get Citizen Details by Citizen ID
     */
    fullContactDetailsByCitizenId(id: string): Promise<TUOCitizenLookupResult> {
        let url_ = this.baseUrl + "/TUO/detailsbycitizenid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFullContactDetailsByCitizenId(_response);
        });
    }

    protected processFullContactDetailsByCitizenId(response: Response): Promise<TUOCitizenLookupResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUOCitizenLookupResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUOCitizenLookupResult>(null as any);
    }

    /**
     * Get TUO Events by ticks.
     */
    getEventsSinceTicks(details: TUOMessageSinceTicksLookUpDetail): Promise<TUOMessage[]> {
        let url_ = this.baseUrl + "/TUO/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(details);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventsSinceTicks(_response);
        });
    }

    protected processGetEventsSinceTicks(response: Response): Promise<TUOMessage[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUOMessage[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUOMessage[]>(null as any);
    }

    /**
     * Get TUO Events by date.
     */
    getEventsSinceDate(details: TUOMessageDateFromAndToLookUpDetail): Promise<TUOMessage[]> {
        let url_ = this.baseUrl + "/TUO/eventsbydate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(details);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventsSinceDate(_response);
        });
    }

    protected processGetEventsSinceDate(response: Response): Promise<TUOMessage[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TUOMessage[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TUOMessage[]>(null as any);
    }

    /**
     * Get Citizen Ids have had updates
     */
    getCitizenIdChanges(): Promise<string[]> {
        let url_ = this.baseUrl + "/TUO/citizenidchanges";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCitizenIdChanges(_response);
        });
    }

    protected processGetCitizenIdChanges(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class UserDataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Synchorise the contact record with B2C
     */
    syncUserDetails(): Promise<void> {
        let url_ = this.baseUrl + "/UserData/synchronise";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncUserDetails(_response);
        });
    }

    protected processSyncUserDetails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Disables the Citizen's B2C Account
     */
    deactivateUser(removeLinkedServices: boolean): Promise<boolean> {
        let url_ = this.baseUrl + "/UserData/deactivate/{removeLinkedServices}";
        if (removeLinkedServices === undefined || removeLinkedServices === null)
            throw new Error("The parameter 'removeLinkedServices' must be defined.");
        url_ = url_.replace("{removeLinkedServices}", encodeURIComponent("" + removeLinkedServices));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeactivateUser(_response);
        });
    }

    protected processDeactivateUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Send OTP
     */
    sendOTP(): Promise<boolean> {
        let url_ = this.baseUrl + "/UserData/deactivate/sendotp";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendOTP(_response);
        });
    }

    protected processSendOTP(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Confirm OTP
     */
    confirmOTP(code: string): Promise<boolean> {
        let url_ = this.baseUrl + "/UserData/deactivate/confirmotp/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmOTP(_response);
        });
    }

    protected processConfirmOTP(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class StaffUserDataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    /**
     * Updates a given citizen's Email Address/username in Azure B2C
     * @param newEmail (optional) 
     */
    changeEmailAddress(citizenId: string, newEmail: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/StaffUserData/{citizenId}/email?";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        if (newEmail === null)
            throw new Error("The parameter 'newEmail' cannot be null.");
        else if (newEmail !== undefined)
            url_ += "newEmail=" + encodeURIComponent("" + newEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeEmailAddress(_response);
        });
    }

    protected processChangeEmailAddress(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Resets a citizen's password in Azure B2C
     */
    resetCitizenPassword(citizenId: string): Promise<string> {
        let url_ = this.baseUrl + "/StaffUserData/{citizenId}/passwordReset";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetCitizenPassword(_response);
        });
    }

    protected processResetCitizenPassword(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Synchorise the contact record with B2C
     */
    syncUserDetails(citizenId: string): Promise<void> {
        let url_ = this.baseUrl + "/StaffUserData/synchronise/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncUserDetails(_response);
        });
    }

    protected processSyncUserDetails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Force a reregister of the Citizen's MFA
     */
    removeMFA(citizenId: string): Promise<void> {
        let url_ = this.baseUrl + "/StaffUserData/reregister/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveMFA(_response);
        });
    }

    protected processRemoveMFA(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Disables the Citizen's B2C Account
     */
    deactivateUser(citizenId: string, deactivateUserViewModel: DeactivateUserViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/StaffUserData/deactivate/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deactivateUserViewModel);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeactivateUser(_response);
        });
    }

    protected processDeactivateUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Reenable the Citizen's B2C Account
     */
    reactivateUser(citizenId: string): Promise<void> {
        let url_ = this.baseUrl + "/StaffUserData/reactivate/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReactivateUser(_response);
        });
    }

    protected processReactivateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VerificationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    validate(documentDetails: DocumentValidation): Promise<boolean> {
        let url_ = this.baseUrl + "/Verification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    validateDocument(documentDetails: DocumentValidation): Promise<boolean> {
        let url_ = this.baseUrl + "/Verification/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateDocument(_response);
        });
    }

    protected processValidateDocument(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class StaffVerificationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    validate(citizenId: string, documentDetails: DocumentValidation): Promise<boolean> {
        let url_ = this.baseUrl + "/StaffVerification/{citizenId}";
        if (citizenId === undefined || citizenId === null)
            throw new Error("The parameter 'citizenId' must be defined.");
        url_ = url_.replace("{citizenId}", encodeURIComponent("" + citizenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentDetails);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface DocumentResponse {
    id: string;
    deliveryDate: string;
}

export interface ProblemDetails {
    type: string | null;
    title: string | null;
    status: number | null;
    detail: string | null;
    instance: string | null;
    extensions: { [key: string]: any; };

    [key: string]: any;
}

export interface TestMessageFormat {
    message: string;
}

export interface MessageResponse {
    id: string;
    deliveryDate: string;
}

export interface Message {
    citizenId: string;
    subject: string;
    priority: MessagePriority;
    body: string;
    bodyType: MessageBodyType;
    batchId: string | null;
    retentionMonths: number | null;
    deliveryDate: string | null;
    isSecure: boolean;
    isNotifiable: boolean;
    smsMessage: string | null;
}

export enum MessagePriority {
    HIGH = "HIGH",
    NORMAL = "NORMAL",
    LOW = "LOW",
}

export enum MessageBodyType {
    PLAIN = "PLAIN",
    HTML = "HTML",
}

export interface EmailResult {
    success: boolean;
    error: string | null;
    emailOperationId: string | null;
}

export interface ViewMessage {
    id: string;
    subject: string;
    deliveryDate: string;
    expiryDate: string | null;
    notifiable: boolean;
    retentionMonths: number;
    secure: boolean;
    body: string;
    batchId: string | null;
    priority: MessagePriority;
    service: string;
}

export interface ViewVerifiedDocument {
    verifiedDate: string;
    uniqueDocumnentId: string;
    type: string;
}

export interface ViewDocument {
    id: string;
    name: string | null;
    type: DocumentType;
    expiryDate: string | null;
    deliveryDate: string;
    isSecure: boolean;
    service: string;
    storageStatus: DVStorageStatus;
}

export enum DocumentType {
    Certificate = "Certificate",
    Licence = "Licence",
    Receipts = "Receipts",
    Notices = "Notices",
}

export enum DVStorageStatus {
    Active = 928220000,
    Deleted = 928220001,
    Archived = 928220002,
}

export interface InternalContactDetails {
    firstName: string;
    lastName: string;
    preferredName: string | null;
}

export interface CitizenDetails {
    firstName: string;
    lastName: string;
    citizenId: string;
    contactId: string;
    clientId: string;
}

export interface ImpersonateRecord {
    firstName: string;
    lastName: string;
    citizenId: string;
    clientID: string;
    dontCallMRS: boolean;
}

export interface ExtraTypes {
    ui1: UiFileType;
    searchForm: SearchForm;
    ack: AcknowledgeService;
    lookupTemp: MRSTUPVehicleLookup;
    mrsReceiptConfirmation: MRSReceiptConfirmation;
    tupAck: MRSTUPAcknowledgeService;
}

export enum UiFileType {
    DocumentValidation = "DocumentValidation",
    PortalDocument = "PortalDocument",
    Message = "Message",
    ClientLink = "ClientLink",
    LicenceDetails = "LicenceDetails",
    LicenceRenewalRequest = "LicenceRenewalRequest",
    MRSRegistrationSummary = "MRSRegistrationSummary",
    MRSClientSummary = "MRSClientSummary",
    ClientLinkLicence = "ClientLinkLicence",
    ClientLinkRegistration = "ClientLinkRegistration",
    ImpersonateRecord = "ImpersonateRecord",
    MRSLicenceRenewalRequest = "MRSLicenceRenewalRequest",
    RegistrationRenewalRequest = "RegistrationRenewalRequest",
    MRSRegistrationSearch = "MRSRegistrationSearch",
    MRSCreateClient = "MRSCreateClient",
    MRSVehicleLookup = "MRSVehicleLookup",
    MRSShortTermRegistrationQuote = "MRSShortTermRegistrationQuote",
    MRSUnknownSTPConfirmation = "MRSUnknownSTPConfirmation",
    ShortTermRegistrationPermitConfirmation = "ShortTermRegistrationPermitConfirmation",
    MRSKnownSTPConfirmation = "MRSKnownSTPConfirmation",
    UpdateAddress = "UpdateAddress",
}

export interface SearchForm {
    resultCount: SearchResultCount | null;
    request: SearchFormRequest;
}

export interface SearchResultCount {
    total: number;
    firstResult: number;
    lastResult: number;
    resultName: string;
}

export interface SearchFormRequest {
    orderBy: string;
    perPage: number;
    page: number;
}

export interface AcknowledgeService {
    acknowledged: boolean;
    contact: MyContactDetails;
}

export interface MyContactDetails {
    firstName: string | null;
    lastName: string | null;
    mobilePhone: string | null;
    fullAddress: string | null;
    emailAddress: string | null;
    alternativeNumber: string | null;
    dateOfBirth: string | null;
    linkedServices: string[];
}

export interface MRSTUPVehicleLookup {
    clientId: string;
    plateNumber: string;
    vin: string | null;
    chassisNumber: string | null;
}

export interface MRSReceiptConfirmation {
    receipt: string;
    failure: boolean;
}

export interface MRSTUPAcknowledgeService {
    acknowledged: boolean;
}

export interface LinkLicenceResponse {
    linked: boolean;
    nameMatch: boolean | null;
    name: string | null;
}

export interface ClientLinkLicence {
    licenceNumber: string;
    cardNumber: string;
}

export interface NameMatchResponse {
    nameMatch: boolean;
    name: string | null;
}

export interface ClientLinkRegistration {
    registrationNumber: string;
    vin: string;
}

export interface MRSClientSummary {
    client: MRSClient;
    licence: MRSLicenceSummary;
    demerits: MRSDemeritSummary | null;
    demeritDetails: DemeritDetail[] | null;
    registrations: MRSRegistrationSummary[] | null;
    concessions: Concession[];
    pogb: PogbDetail[] | null;
}

export interface MRSClient {
    clientId: number;
    name: string;
    externalConfirm: boolean | null;
    externalId: string;
    verified: boolean | null;
    testPassed: boolean | null;
}

export interface MRSLicenceSummary {
    licenceNumber: string;
    licenceId: number;
    expiry: string | null;
    hasDriver: boolean | null;
    hasRider: boolean | null;
    hasRestrictions: boolean | null;
    hasConditions: boolean | null;
    riderClass: MRSLicenceClassSummary | null;
    driverClass: MRSLicenceClassSummary | null;
}

export interface MRSLicenceClassSummary {
    typeCode: string;
    typeDescription: string;
    statusCode: string;
    statusDescription: string;
    classCode: string;
    classDescription: string;
    isLearner: boolean;
    maxDemeritsPoints: string;
    expiryDate: string | null;
    expiresSoon: boolean;
    cantRenewOnline: boolean;
    cantRenewOnlineReason: string | null;
}

export interface MRSDemeritSummary {
    activePoints: number | null;
    totalPoints: number | null;
    timePeriod: number | null;
}

export interface DemeritDetail {
    offenceDate: string | null;
    appliedDate: string | null;
    points: number | null;
    description: string;
    suspension: boolean | null;
    pogb: boolean | null;
}

export interface MRSRegistrationSummary {
    id: number;
    status: string;
    plateNumber: string;
    description: string;
    hasDefects: boolean | null;
    renewalAvailable: boolean | null;
    transferAvailable: boolean | null;
    transferPending: boolean | null;
    disposalAvailable: boolean | null;
    disposalPending: boolean | null;
    isVehicleStolen: boolean | null;
    isVehicleStatutoryWriteOff: boolean | null;
    isVehicleRepairableWriteOff: boolean | null;
    bikePlateEligible: boolean | null;
    registrationExpiry: string | null;
    colour: string | null;
    expiresSoon: boolean | null;
}

export interface Concession {
    code: string;
    date: string | null;
    type: string;
    description: string;
}

export interface PogbDetail {
    pogbId: string;
    status: string;
    startDate: string | null;
    endDate: string | null;
    penalty: number | null;
}

export interface LicenceDetail {
    medicalCheckExpiring: boolean;
    medicalCheckExpired: boolean;
    client: Client;
    licenceNumber: string;
    cardNumber: string;
    licenceId: number | null;
    hasRestrictions: boolean | null;
    hasConditions: boolean | null;
    hasCertificates: boolean | null;
    hasConcession: boolean | null;
    licRestrictions: string[];
    ancillaryCertificates: AncillaryCertificate[];
    licConditions: LicenceCondition[];
    driverStatus: LicenceStatus;
    driverClassCode: string;
    driverClassDescription: string;
    driverClassExpiry: string | null;
    riderStatus: LicenceStatus;
    expiry: string | null;
    physicalAddress: Address;
    postalAddress: Address;
    driverClass: LicenceClassSummary;
    riderClass: LicenceClassSummary;
    medicalCheck: string | null;
    certificates: Certificates[];
    demerits: DemeritDetail[];
    pogb: PogbDetail[];
    renewalAvailable: boolean | null;
}

export interface Client {
    clientId: number | null;
    name: string;
    externalConfirm: boolean | null;
    externalId: string;
    verified: boolean | null;
    testPassed: boolean | null;
}

export interface AncillaryCertificate {
    code: string;
    description: string;
    expiry: string | null;
}

export interface LicenceCondition {
    code: string;
    description: string;
}

export interface LicenceStatus {
    code: string;
    description: string;
}

export interface Address {
    id: string;
    line1: string;
    line2: string;
    line3: string;
    suburb: string;
    state: string;
    postCode: string;
    country: string;
    addressSingleLine: string;
    addressMultiLine: string;
}

export interface LicenceClassSummary {
    expiryDate: string | null;
    expiresSoon: boolean;
    cantRenewOnline: boolean;
    cantRenewOnlineReason: string | null;
    cantRenewOnlineCode: number | null;
    isLearner: boolean;
    header: string | null;
    renewalAvailable: boolean;
    upgradesTo: string | null;
    upgradesOn: string | null;
    type: LicenceType;
    status: LicenceStatus;
    class: LicClass;
    upgrade: LicenceClassUpgrade;
}

export interface LicenceType {
    maxDemeritPoints: string;
    code: string;
    description: string;
}

export interface LicClass {
    code: string;
    description: string;
    expiryDate: string | null;
}

export interface LicenceClassUpgrade {
    upgradesTo: string;
    upgradesOn: string | null;
}

export interface Certificates {
    type: string;
    condition: string;
    description: string;
}

export interface MRSLicenceRenewalQuote {
    correlationId: string | null;
    renewLearner: boolean;
    renewalOptions: PaymentOption[];
}

export interface PaymentOption {
    term: string;
    newExpiry: string | null;
    unavailableReason: string;
    cost: number | null;
    costLineItems: LineItem[];
    concessionApplied: boolean | null;
    concessionDescription: string;
    bPayBillerCode: string;
    bPayReference: string;
    bPayViewCode: string;
}

export interface LineItem {
    sequenceNumber: number | null;
    feeCode: string;
    description: string;
    amount: number | null;
}

export interface MRSConfirmationResponse {
    paymentComplete: boolean;
    receiptNumber: string | null;
}

export interface MRSLicenceRenewalRequest {
    paymentReference: string;
    paymentAmount: number;
    renewDriver: boolean;
    renewRider: boolean;
    renewalPeriod: string;
    correlationId: string | null;
    renewLearner: boolean;
}

export interface MRSPagingRegistrationSummary {
    totalCount: number;
    registrations: MRSRegistrationSummary[];
}

export interface MRSRegistrationSearch {
    page: number;
    pageSize: number;
    orderType: OrderType;
    descending: boolean;
    term: string | null;
}

export enum OrderType {
    ExpiryDate = 0,
    Alphabetical = 1,
}

export interface RegistrationSummary {
    expiresSoon: boolean;
    id: number | null;
    status: string;
    plateNumber: string;
    make: string;
    model: string;
    colour: string;
    year: string;
    description: string;
    expiry: string | null;
    hasDefects: boolean | null;
    renewalAvailable: boolean | null;
    transferAvailable: boolean | null;
    transferPending: boolean | null;
    disposalAvailable: boolean | null;
    disposalPending: boolean | null;
    bikePlateEligible: boolean | null;
    isVehicleStolen: boolean | null;
    isVehicleStatutoryWriteOff: boolean | null;
    isVehicleRepairableWriteOff: boolean | null;
}

export interface RegistrationDetail extends RegistrationSummary {
    registrationCertificateAvailable: boolean;
    carType: RegistrationCarType;
    tpiCode: string;
    tpiDescription: string;
    tupEligible: boolean | null;
    tupAvailable: boolean | null;
    tupUnavailableReason: string;
    registrationType: string;
    nominatedOperator: Operator;
    otherOperator: Operator;
    vehicleInformation: VehicleSummary;
    garageAddress: Address;
    isVehicleStolen: boolean | null;
    isVehicleStatutoryWriteOff: boolean | null;
    isVehicleRepairableWriteOff: boolean | null;
    bikePlateEligible: boolean | null;
    conditions: VehicleCondition[];
    concessions: Concession[];
    defects: Defect[];
    gcm: number | null;
    classification: string;
    vehicleUseTye: string;
    vehicleAxles: number | null;
    expiryDate: string | null;
}

export enum RegistrationCarType {
    Car = "Car",
    Bike = "Bike",
    ElectricCar = "ElectricCar",
    Other = "Other",
}

export interface Operator {
    licenceNumber: string;
    firstName: string;
    familyName: string;
    otherNames: string;
    dateOfBirth: string | null;
    address: Address;
}

export interface VehicleSummary {
    vin: string;
    engineNumber: string;
    make: string;
    vehicleType: string;
    model: string;
    colour1: string;
    colour2: string;
    manufactureMonth: string;
    manufactureYear: string;
    cylinderCount: string;
    cylinderConfig: string;
    engineCapacity: number | null;
    motorKWs: number | null;
    primaryMotivePower: string;
    secondaryMotivePower: string;
    seatCount: number | null;
}

export interface VehicleCondition {
    date: string | null;
    code: string;
    description: string;
}

export interface Defect {
    date: string | null;
    status: string;
    type: string;
    comment: string;
    inspectionRequired: boolean | null;
    clearDate: string | null;
}

export interface RegistrationRenewalQuote {
    correlationId: string | null;
    renewalOptions: PaymentOption[];
}

export interface MRSRegistrationRenewalRequest {
    paymentReference: string;
    paymentAmount: number;
    period: RegistrationRenewalRequestPeriod;
    correlationId: string | null;
}

export enum RegistrationRenewalRequestPeriod {
    _1 = 1,
    _3 = 3,
    _6 = 6,
    _12 = 12,
}

export interface PlatesOrderQuote {
    registrationSummary: RegistrationSummary;
    garageAddress: Address;
    pricingOptions: PaymentOption[];
}

export interface MRSPaymentDetails {
    id: string;
    amount: number;
}

export interface MRSCreateClient {
    gender: CreateClientGender | null;
}

export enum CreateClientGender {
    Male = 0,
    Female = 1,
    Unspecified = 2,
}

export interface MRSCompareAddress {
    residentialAddressDifferent: boolean | null;
    postalAddressDifferent: boolean | null;
    residentialAddress: Address | null;
    postalAddress: Address | null;
    residentialAddressErrorMessage: string | null;
    postalAddressErrorMessage: string | null;
}

export interface MRSAddressUpdateResult {
    residentialAddressUpdateSuccessful: boolean | null;
    postalAddressUpdateSuccessful: boolean | null;
    garageAddressUpdateSuccessful: boolean | null;
    message: string;
    id: string;
}

export interface MRSUpdateAddress {
    updateResidentialAddress: boolean | null;
    updatePostalAddress: boolean | null;
}

export interface MRSTUPLookupResponse {
    clientId: string;
    clientName: string;
    make: string;
    model: string;
    colour: string;
    status: string;
    tupEligible: boolean;
    tupAvailable: boolean;
    tupUnavailableReason: string | null;
    expiry: string | null;
    registrationId: number | null;
}

export interface TUPsForm {
    currentPage: number;
    tupDetails: TUPDetail;
    toClassification: string;
    tupQuote: TUPQuote;
    tupQuoteResponse: TUPQuoteResponse;
    tupConfirmationRequest: TUPConfirmationRequest;
    tupVehicleDetails: TUPVehicleDetail;
    receiptNumber: string | null;
    paymentOptions: PaymentOptions;
    ownVehicle: boolean | null;
    tupVehicleLookup: MRSTUPVehicleLookup;
    tupLookupResponse: MRSSTPLookupResponse | null;
    selectedVehicleId: number | null;
    existingVehicles: MRSRegistrationLookup[];
}

export interface TUPDetail {
    grossCombinedMass: number;
    currentClassification: string;
    vehicleUseType: string;
    axles: number;
    expiry: string | null;
    upgradeOptions: UpgradeOption[];
}

export interface UpgradeOption {
    classification: string;
    vehicleUseType: string;
    grossCombinationMass: number;
    vehicleAxles: number;
    imageUrl: string | null;
    description: string | null;
}

export interface TUPQuote {
    registrationId: number;
    startDate: string | null;
    endDate: string | null;
    fromClassification: string;
    toClassification: string | null;
}

export interface TUPQuoteResponse {
    correlationId: string;
    permitFee: number | null;
    permitLineItems: LineItem[];
}

export interface TUPConfirmationRequest {
    paymentReference: string | null;
    paymentAmount: number | null;
    correlationId: string;
    registrationId: number;
    currentFeeCode: string;
    newFeeCode: string;
    combinationAxles: number;
    declaration: boolean | null;
    startDate: string;
    endDate: string;
    paymentReceiptNumber: string;
}

export interface TUPVehicleDetail {
    plateNumber: string;
    make: string;
    model: string;
    description: string;
}

export interface PaymentOptions {
    paymentType: PaymentType | null;
    paymentAvailability: PaymentAvailability;
}

export enum PaymentType {
    CreditCard = "CreditCard",
    GooglePay = "GooglePay",
    ApplePay = "ApplePay",
}

export interface PaymentAvailability {
    applePay: boolean | null;
    googlePay: boolean | null;
    creditCard: boolean | null;
}

export interface MRSSTPLookupResponse {
    make: string;
    model: string;
    colour: string;
    engineSize: string | null;
    registrationId: number | null;
}

export interface MRSRegistrationLookup {
    registrationId: number;
    description: string;
}

export interface TUPPaymentResponse {
    paymentReference: string;
    paymentAmount: number;
    receiptNumber: string;
}

export interface TUPPaymentRequest {
    singleUseTokenId: string;
    quote: TUPQuote;
}

export interface CreateTUPRequest {
    currentClassification: string | null;
    toClassification: string | null;
    startDate: string | null;
    endDate: string | null;
    axles: number | null;
    toVehicleAxles: number | null;
    declaration: boolean | null;
    receiptNumber: string | null;
    registrationId: number | null;
    vehicleDescription: string | null;
    ownVehicle: boolean | null;
    plateNumber: string | null;
    make: string | null;
    model: string | null;
    colour: string | null;
}

export interface TUPSummary {
    id: string;
    status: TUPStatus;
    receiptNumber: string | null;
    vehicleDescription: string | null;
    plateNumber: string | null;
    currentClassification: string | null;
    toClassification: string | null;
    startDate: string | null;
    endDate: string | null;
}

export enum TUPStatus {
    Draft = "Draft",
    Submitted = "Submitted",
}

export interface MRSVehicleLookup {
    plateNumber: string;
    lookupType: MRSVehicleLookupType;
}

export enum MRSVehicleLookupType {
    Plate = 0,
    Chasis = 1,
    VIN = 2,
}

export interface ShortTermRegistrationQuoteResponse {
    correlationId: string;
    receiptNumber: string;
    permitFee: number | null;
    permitLineItems: LineItem[];
}

export interface MRSShortTermRegistrationQuote {
    vehicleType: STPVehicleType | null;
    unladenMass: STPUnladenMass | null;
    bodyTypeCode: number | null;
    registrationId: number | null;
    journeys: number;
    startDate: string;
    endDate: string;
}

export enum STPVehicleType {
    MotorVehicle = "MotorVehicle",
    Trailer = "Trailer",
}

export enum STPUnladenMass {
    LessThanOrEqualTo500 = "LessThanOrEqualTo500",
    Over500 = "Over500",
}

export interface MRSShortTermRegistrationPermitConfirmation {
    stpJourneyType: STPJourneyType;
    registrationId: number;
    journeyDetails: JourneyDetails[];
    paymentReference: string;
    paymentAmount: number;
    eventName: string | null;
    eventDate: string | null;
    correlationId: string | null;
}

export enum STPJourneyType {
    Relocation = "Relocation",
    Repairs = "Repairs",
    Event = "Event",
}

export interface JourneyDetails {
    number: number;
    purpose: string;
    startDate: string;
    endDate: string;
    origin: string;
    destination: string;
}

export interface MRSUnknownShortTermRegistrationPermitConfirmation {
    bodyTypeCode: number;
    vehicleType: STPVehicleType;
    unladenMass: STPUnladenMass | null;
    vin: string;
    colour: string;
    makeCode: number;
    journeyDetails: JourneyDetails[];
    paymentReference: string;
    paymentAmount: number;
    correlationId: string;
    eventDate: string | null;
    eventName: string | null;
    stpJourneyType: STPJourneyType;
}

export interface B2CError {
    version: string;
    status: number;
    userMessage: string;
}

export enum PortalPage {
    TFS = "TFS",
    MRS = "MRS",
}

export interface SearchResultsOfFirePermitSummary {
    offset: number;
    length: number;
    count: number | null;
    results: FirePermitSummary[];
}

export interface FirePermitSummary {
    id: string;
    date: string;
    status: FirePermitStatus;
    type: TypeOfFireForm;
    escadNumber: string | null;
    receiptNumber: string | null;
    propertyAddress: string;
    editAvailable: boolean;
}

export enum FirePermitStatus {
    Draft = "Draft",
    Registered = "Registered",
    Submitted = "Submitted",
    Error = "Error",
}

export enum TypeOfFireForm {
    Permit = "Permit",
    BurnRegistration = "BurnRegistration",
}

export enum Itg_typeoffireform {
    Permit = 0,
    BurnRegistration = 1,
}

export interface FireRegistrationAndLocation {
    registration: FireRegistration;
    contact: MyContactDetails;
    locationStatus: FireDates | null;
    baseUrl: string | null;
}

export interface FireRegistration {
    startDate: string;
    startTime: string;
    area: number | null;
    endDate: string | null;
    endTime: string | null;
    sentOn: string | null;
    fuelArrangement: FuelArrangement | null;
    nameOfBrigadeInAttendance: string | null;
    doYouRequireMultiLights: boolean | null;
    isYourFireLargerThan1MeterCubed: boolean;
    isYourPropertyLargerThan2000MetersSquared: boolean | null;
    materialsBeingBurnt: MaterialsBeingBurnt | null;
    materialsBeingBurntOther: string | null;
    purpose: string | null;
    acknowledgement: boolean | null;
    otherDetails: string | null;
    escadIncidentNumber: string | null;
    name: string | null;
    receiptNumber: string | null;
    fireUnitSize: FireUnitSize | null;
    latitude: number | null;
    longitude: number | null;
    propertyAddress: string | null;
    typeOfFireForm: TypeOfFireForm;
    fpAndTFBStatus: string | null;
    nearestRoadOrLandmark: string | null;
    insidePermitPeriod: boolean;
    insideFireBanPeriod: boolean;
    datesValid: boolean;
}

export enum FuelArrangement {
    Cut = "Cut",
    Piles = "Piles",
    Standing = "Standing",
}

export enum MaterialsBeingBurnt {
    Grass = "Grass",
    BushScrub = "BushScrub",
    LogHeaps = "LogHeaps",
    LoggingSlash = "LoggingSlash",
    GardenWaste = "GardenWaste",
    CropResidue = "CropResidue",
    MixedFuels = "MixedFuels",
    Other = "Other",
    DomesticFirePot = "DomesticFirePot",
    WoodfiredCooker = "WoodfiredCooker",
    Bonfire = "Bonfire",
}

export enum FireUnitSize {
    CubicMetres = "CubicMetres",
    Hectares = "Hectares",
}

export interface FireDates {
    area: string;
    permit: DateRange | null;
    fireBan: DateRange | null;
}

export interface DateRange {
    start: string;
    end: string | null;
}

export interface ReceiptConfirmation {
    receipt: string;
    formType: TypeOfFireForm;
    failure: boolean;
}

export interface InitialFireRegistration {
    location: string;
    allowedToBurn: boolean | null;
    locationStatus: FireDates | null;
    details: FireRegistrationEdit;
    typeOfFireForm: TypeOfFireForm;
    burnRegistrationEnabled: boolean;
    initialType: TypeOfFireForm;
    nearestRoadOrLandmark: string | null;
    containsAddress: boolean | null;
}

export interface FireRegistrationEdit {
    registration: FireRegistration;
    contact: MyContactDetails;
    baseUrl: string | null;
}

export enum InitialFireOutcomeType {
    BurnRegistration = 0,
    FirePermit = 1,
    TotalFireBan = 2,
}

export interface CitizenLookupDetails {
    givenNames: string;
    surname: string;
    dob: string | null;
}

export interface TUOCitizenLookupResult {
    givenNames: string;
    surname: string;
    dob: string | null;
    emailAddress: string | null;
    mobilePhone: string | null;
    citizenId: string;
    verifiedAttributes: VerifiedAttributes[];
    residentialAddress: TUOAddress;
    postalAddress: TUOAddress;
}

export interface VerifiedAttributes {
    name: boolean;
    dob: boolean;
    uicCount: number;
    coiCount: number;
}

export interface TUOAddress {
    full: string;
    verified: boolean;
    line1: string | null;
    line2: string | null;
    suburb: string | null;
    state: string | null;
    postCode: string | null;
    addressLookupId: string | null;
    validatedAddressInformation: string | null;
    noFixedAddress: boolean | null;
    dpid: string | null;
}

export interface TUOMessage {
    transactionId: string;
    citizenId: string;
    eventType: EventType;
    change: any | null;
    data: any | null;
    currentGivenNames: string;
    currentSurname: string;
    dob: string | null;
    prevGivenNames: string | null;
    prevSurname: string | null;
    changeDate: string;
    emailAddress: string | null;
    mobilePhone: string | null;
    ticks: number;
    verifiedAttributes: VerifiedAttributes;
    residentialAddress: TUOAddress | null;
    postalAddress: TUOAddress | null;
    service: string;
}

export enum EventType {
    Name = "Name",
    ResidentialAddress = "ResidentialAddress",
    PostalAddress = "PostalAddress",
    DOB = "DOB",
    Mobile = "Mobile",
    Email = "Email",
    Signup = "Signup",
    LinkService = "LinkService",
    UnlinkService = "UnlinkService",
    Deactivation = "Deactivation",
    Reactivation = "Reactivation",
    VerifiedAttributes = "VerifiedAttributes",
    CitizenIDChange = "CitizenIDChange",
    ConsentChange = "ConsentChange",
}

export interface TUOMessageSinceTicksLookUpDetail {
    citizenId: string | null;
    ticks: number;
    type: EventType | null;
}

export interface TUOMessageDateFromAndToLookUpDetail {
    citizenId: string | null;
    dateFrom: string;
    dateTo: string;
    type: EventType | null;
}

export interface DeactivateUserViewModel {
    mergeEvent: boolean;
    serviceLinkAction: ServiceLinkAction;
    newCitizenId: string | null;
}

export enum ServiceLinkAction {
    RemoveServiceLinks = 0,
    ForceLinks = 1,
    Nothing = 2,
}

export interface DocumentValidation {
    type: DocumentValidationType;
}

export enum DocumentValidationType {
    BirthCertificate = "BirthCertificate",
    AustralianPassport = "AustralianPassport",
    Visa = "Visa",
    ImmiCard = "ImmiCard",
    DriversLicence = "DriversLicence",
    NameChangeCertificate = "NameChangeCertificate",
    MarriageCertificate = "MarriageCertificate",
    MedicareCard = "MedicareCard",
    ServicesAustraliaCard = "ServicesAustraliaCard",
    CitizenshipCertificate = "CitizenshipCertificate",
    CertificateOfRegistryByDescent = "CertificateOfRegistryByDescent",
    ASIC_MSIC_Card = "ASIC_MSIC_Card",
    MRS = "MRS",
}

export interface BirthCertificateValidation extends DocumentValidation {
    registrationState: StateType;
    certificateNumber: string | null;
    registrationNumber: string | null;
    registrationDate: string | null;
}

export enum StateType {
    TAS = "TAS",
    NSW = "NSW",
    VIC = "VIC",
    ACT = "ACT",
    NT = "NT",
    WA = "WA",
    SA = "SA",
    QLD = "QLD",
}

export interface MarriageCertificateValidation extends DocumentValidation {
    registrationState: StateType;
    otherGivenName: string;
    otherFamilyName: string;
    isPerson1: boolean;
    certificateNumber: string | null;
    registrationDate: string | null;
    registrationNumber: string | null;
}

export interface NameChangeCertificateValidation extends DocumentValidation {
    registrationState: StateType;
    certificateNumber: string | null;
    registrationDate: string | null;
    registrationNumber: string | null;
}

export interface DriversLicenceValidation extends DocumentValidation {
    registrationState: StateType;
    licenseNumber: string;
    cardNumber: string | null;
}

export interface AustralianPassportValidation extends DocumentValidation {
    travelDocumentNumber: string;
    gender: string | null;
}

export interface MedicareCardValidation extends DocumentValidation {
    fullName2: string | null;
    fullName3: string | null;
    fullName4: string | null;
    cardNumber: string;
    individualRefNumber: string;
    cardType: string;
    cardExpiry: string;
}

export interface VisaValidation extends DocumentValidation {
    passportNumber: string;
}

export interface ServicesAustraliaCardValidation extends DocumentValidation {
    customerReferenceNumber: string;
    cardType: string;
    cardExpiry: string;
}

export interface CitizenshipCertificateValidation extends DocumentValidation {
    stockNumber: string;
    acquisitionDate: string;
}

export interface CertificateOfRegistryByDescentValidation extends DocumentValidation {
    stockNumber: string;
    acquisitionDate: string;
}

export interface ImmiCardValidation extends DocumentValidation {
    immiCardNumber: string;
}

export interface AsicMsicCardValidation extends DocumentValidation {
    cardType: string;
    cardExpiry: string;
    cardNumber: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}