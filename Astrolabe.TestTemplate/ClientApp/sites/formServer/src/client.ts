//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class CarClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:5001";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CarEdit | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Car";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    listPublished(): Promise<CarEdit[]> {
        let url_ = this.baseUrl + "/api/Car";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListPublished(_response);
        });
    }

    protected processListPublished(response: Response): Promise<CarEdit[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarEdit[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarEdit[]>(null as any);
    }

    /**
     * @param workflowAction (optional) 
     * @return OK
     */
    workflowAction(id: string, workflowAction: CarWorkflow | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Car/{id}/actions?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowAction === null)
            throw new Error("The parameter 'workflowAction' cannot be null.");
        else if (workflowAction !== undefined)
            url_ += "workflowAction=" + encodeURIComponent("" + workflowAction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWorkflowAction(_response);
        });
    }

    protected processWorkflowAction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getWorkflowActions(id: string): Promise<CarWorkflow[]> {
        let url_ = this.baseUrl + "/api/Car/{id}/actions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkflowActions(_response);
        });
    }

    protected processGetWorkflowActions(response: Response): Promise<CarWorkflow[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarWorkflow[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarWorkflow[]>(null as any);
    }

    /**
     * @param workflowAction (optional) 
     * @return OK
     */
    bulkWorkflowAction(workflowAction: CarWorkflow | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Car/actions?";
        if (workflowAction === null)
            throw new Error("The parameter 'workflowAction' cannot be null.");
        else if (workflowAction !== undefined)
            url_ += "workflowAction=" + encodeURIComponent("" + workflowAction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkWorkflowAction(_response);
        });
    }

    protected processBulkWorkflowAction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    edit(id: string, body: CarEdit | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Car/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEdit(_response);
        });
    }

    protected processEdit(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    searchCars(body: SearchOptions | undefined): Promise<CarInfoSearchResults> {
        let url_ = this.baseUrl + "/api/Car/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchCars(_response);
        });
    }

    protected processSearchCars(response: Response): Promise<CarInfoSearchResults> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarInfoSearchResults;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarInfoSearchResults>(null as any);
    }

    /**
     * @return OK
     */
    listAll(): Promise<CarInfo[]> {
        let url_ = this.baseUrl + "/api/Car/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListAll(_response);
        });
    }

    protected processListAll(response: Response): Promise<CarInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarInfo[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generatePdf(body: PdfData | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Car/pdf";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGeneratePdf(_response);
        });
    }

    protected processGeneratePdf(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class CodeGenClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:5001";
    }

    /**
     * @return OK
     */
    getSchemas(): Promise<string> {
        let url_ = this.baseUrl + "/api/CodeGen/Schemas";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSchemas(_response);
        });
    }

    protected processGetSchemas(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    editControlDefinition(body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/CodeGen/ControlDefinition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditControlDefinition(_response);
        });
    }

    protected processEditControlDefinition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    editSchemaFieldDefinition(body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/CodeGen/SchemaField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditSchemaFieldDefinition(_response);
        });
    }

    protected processEditSchemaFieldDefinition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class EvalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:5001";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    eval(body: EvalData | undefined): Promise<EvalResult> {
        let url_ = this.baseUrl + "/api/Eval";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEval(_response);
        });
    }

    protected processEval(response: Response): Promise<EvalResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EvalResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EvalResult>(null as any);
    }
}

export class SearchStateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:5001";
    }

    /**
     * @return OK
     */
    getSchemas(): Promise<string> {
        let url_ = this.baseUrl + "/api/SearchState/Schemas";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSchemas(_response);
        });
    }

    protected processGetSchemas(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getForms(): Promise<string> {
        let url_ = this.baseUrl + "/api/SearchState/Forms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetForms(_response);
        });
    }

    protected processGetForms(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getExtraTypes(): Promise<CarSearchPage> {
        let url_ = this.baseUrl + "/api/SearchState";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExtraTypes(_response);
        });
    }

    protected processGetExtraTypes(response: Response): Promise<CarSearchPage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarSearchPage;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarSearchPage>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    editControlDefinition(id: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/SearchState/ControlDefinition/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditControlDefinition(_response);
        });
    }

    protected processEditControlDefinition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface ControlAdornment {
    type: string;

    [key: string]: any;
}

export interface AccordionAdornment extends ControlAdornment {
    title: string;
    defaultExpanded: boolean | null;

    [key: string]: any;
}

export interface ControlDefinition {
    type: string;
    title: string | null;
    id: string | null;
    childRefId: string | null;
    disabled: boolean | null;
    hidden: boolean | null;
    readonly: boolean | null;
    dynamic: DynamicProperty[] | null;
    adornments: ControlAdornment[] | null;
    styleClass: string | null;
    textClass: string | null;
    layoutClass: string | null;
    labelClass: string | null;
    labelTextClass: string | null;
    placement: string | null;
    children: ControlDefinition[] | null;

    [key: string]: any;
}

export interface ActionControlDefinition extends ControlDefinition {
    actionId: string;
    actionData: string | null;
    icon: IconReference | null;
    actionStyle: ActionStyle | null;
    iconPlacement: IconPlacement | null;
    disableType: ControlDisableType | null;

    [key: string]: any;
}

export enum ActionStyle {
    Button = "Button",
    Secondary = "Secondary",
    Link = "Link",
    Group = "Group",
}

export enum AdornmentPlacement {
    ControlStart = "ControlStart",
    ControlEnd = "ControlEnd",
    LabelStart = "LabelStart",
    LabelEnd = "LabelEnd",
}

export interface RenderOptions {
    type: string;

    [key: string]: any;
}

export interface ArrayElementRenderOptions extends RenderOptions {
    showInline: boolean | null;

    [key: string]: any;
}

export interface ArrayRenderOptions extends RenderOptions {
    addText: string | null;
    removeText: string | null;
    addActionId: string | null;
    removeActionId: string | null;
    editText: string | null;
    editActionId: string | null;
    noAdd: boolean | null;
    noRemove: boolean | null;
    noReorder: boolean | null;
    editExternal: boolean | null;

    [key: string]: any;
}

export interface AutocompleteRenderOptions extends RenderOptions {
    listContainerClass: string | null;
    listEntryClass: string | null;
    chipContainerClass: string | null;
    chipCloseButtonClass: string | null;
    placeholder: string | null;

    [key: string]: any;
}

export interface CarEdit {
    make: string;
    model: string;
    year: number;
}

export interface CarInfo {
    make: string;
    model: string;
    year: number;
    status: ItemStatus;
}

export interface CarInfoSearchResults {
    total: number | null;
    entries: CarInfo[];
}

export interface CarSearchPage {
    request: SearchOptions;
    results: CarInfoSearchResults;
    loading: boolean;
}

export enum CarWorkflow {
    Publish = "Publish",
    Embarrassed = "Embarrassed",
}

export interface CheckListRenderOptions extends RenderOptions {
    entryWrapperClass: string | null;
    selectedClass: string | null;
    notSelectedClass: string | null;

    [key: string]: any;
}

export enum ControlDisableType {
    None = "None",
    Self = "Self",
    Global = "Global",
}

export interface DisplayData {
    type: string;

    [key: string]: any;
}

export interface CustomDisplay extends DisplayData {
    customId: string;

    [key: string]: any;
}

export interface DataControlDefinition extends ControlDefinition {
    field: string;
    hideTitle: boolean | null;
    required: boolean | null;
    renderOptions: RenderOptions | null;
    defaultValue: any | null;
    dontClearHidden: boolean | null;
    validators: SchemaValidator[] | null;

    [key: string]: any;
}

export interface EntityExpression {
    type: string;

    [key: string]: any;
}

export interface DataExpression extends EntityExpression {
    field: string;

    [key: string]: any;
}

export interface DataGroupRenderOptions extends RenderOptions {
    groupOptions: GroupRenderOptions;

    [key: string]: any;
}

export interface DataMatchExpression extends EntityExpression {
    field: string;
    value: any;

    [key: string]: any;
}

export enum DateComparison {
    NotBefore = "NotBefore",
    NotAfter = "NotAfter",
}

export interface DateTimeRenderOptions extends RenderOptions {
    format: string | null;
    forceMidnight: boolean | null;
    forceStandard: boolean | null;

    [key: string]: any;
}

export interface SchemaValidator {
    type: string;

    [key: string]: any;
}

export interface DateValidator extends SchemaValidator {
    comparison: DateComparison;
    fixedDate: string | null;
    daysFromCurrent: number | null;

    [key: string]: any;
}

export interface GroupRenderOptions {
    type: string;
    hideTitle: boolean | null;
    childStyleClass: string | null;
    childLayoutClass: string | null;
    childLabelClass: string | null;
    displayOnly: boolean | null;
}

export interface DialogRenderOptions extends GroupRenderOptions {
    title: string | null;
}

export interface DisplayControlDefinition extends ControlDefinition {
    displayData: DisplayData;

    [key: string]: any;
}

export interface DisplayOnlyRenderOptions extends RenderOptions {
    emptyText: string | null;
    sampleText: string | null;

    [key: string]: any;
}

export interface DynamicProperty {
    type: string;
    expr: EntityExpression;
}

export interface ElementSelectedRenderOptions extends RenderOptions {
    elementExpression: EntityExpression;

    [key: string]: any;
}

export interface EvalData {
    expression: string;
    data: { [key: string]: any; };
}

export interface EvalResult {
    result: ValueWithDeps;
    errors: string[];
}

export interface FlexRenderer extends GroupRenderOptions {
    direction: string | null;
    gap: string | null;
}

export interface GridRenderer extends GroupRenderOptions {
    columns: number | null;
    rowClass: string | null;
}

export interface GroupElementRenderer extends GroupRenderOptions {
    value: any;
}

export interface GroupedControlsDefinition extends ControlDefinition {
    compoundField: string | null;
    groupOptions: GroupRenderOptions | null;

    [key: string]: any;
}

export interface HelpTextAdornment extends ControlAdornment {
    helpText: string;
    placement: AdornmentPlacement | null;

    [key: string]: any;
}

export interface HtmlDisplay extends DisplayData {
    html: string;

    [key: string]: any;
}

export interface HtmlEditorRenderOptions extends RenderOptions {
    allowImages: boolean;

    [key: string]: any;
}

export interface IconAdornment extends ControlAdornment {
    iconClass: string;
    icon: IconReference | null;
    placement: AdornmentPlacement | null;

    [key: string]: any;
}

export interface IconDisplay extends DisplayData {
    iconClass: string;
    icon: IconReference | null;

    [key: string]: any;
}

export interface IconListRenderOptions extends RenderOptions {
    iconMappings: IconMapping[];

    [key: string]: any;
}

export interface IconMapping {
    value: string;
    materialIcon: string | null;
}

export enum IconPlacement {
    BeforeText = "BeforeText",
    AfterText = "AfterText",
    ReplaceText = "ReplaceText",
}

export interface IconReference {
    library: string;
    name: string;
}

export enum ItemStatus {
    Draft = "Draft",
    Published = "Published",
}

export interface JsonataExpression extends EntityExpression {
    expression: string;

    [key: string]: any;
}

export interface JsonataRenderOptions extends RenderOptions {
    expression: string;

    [key: string]: any;
}

export interface JsonataValidator extends SchemaValidator {
    expression: string;

    [key: string]: any;
}

export interface LengthValidator extends SchemaValidator {
    min: number | null;
    max: number | null;

    [key: string]: any;
}

export interface NotEmptyExpression extends EntityExpression {
    field: string;
    empty: boolean | null;

    [key: string]: any;
}

export interface OptionalAdornment extends ControlAdornment {
    placement: AdornmentPlacement | null;
    allowNull: boolean | null;
    editSelectable: boolean | null;

    [key: string]: any;
}

export interface PdfData {
    controls: ControlDefinition[];
    schemaName: string;
    data: any;
}

export interface RadioButtonRenderOptions extends RenderOptions {
    entryWrapperClass: string | null;
    selectedClass: string | null;
    notSelectedClass: string | null;

    [key: string]: any;
}

export interface ScrollListRenderOptions extends RenderOptions {
    bottomActionId: string | null;

    [key: string]: any;
}

export interface SearchOptions {
    offset: number;
    length: number;
    query: string | null;
    sort: string[] | null;
    filters: { [key: string]: string[]; } | null;
}

export interface SelectChildRenderer extends GroupRenderOptions {
    childIndexExpression: EntityExpression;
}

export interface SetFieldAdornment extends ControlAdornment {
    defaultOnly: boolean | null;
    field: string;
    expression: EntityExpression;

    [key: string]: any;
}

export interface SimpleDisplayData extends DisplayData {

    [key: string]: any;
}

export interface SimpleExpression extends EntityExpression {

    [key: string]: any;
}

export interface SimpleGroupRenderOptions extends GroupRenderOptions {
}

export interface SimpleRenderOptions extends RenderOptions {

    [key: string]: any;
}

export interface SimpleValidator extends SchemaValidator {

    [key: string]: any;
}

export enum SyncTextType {
    Camel = "Camel",
    Snake = "Snake",
    Pascal = "Pascal",
}

export interface SynchronisedRenderOptions extends RenderOptions {
    fieldToSync: string;
    syncType: SyncTextType;

    [key: string]: any;
}

export interface TabsRenderOptions extends GroupRenderOptions {
    contentClass: string | null;
}

export interface TextDisplay extends DisplayData {
    text: string;

    [key: string]: any;
}

export interface TextfieldRenderOptions extends RenderOptions {
    placeholder: string | null;
    multiline: boolean | null;

    [key: string]: any;
}

export interface TooltipAdornment extends ControlAdornment {
    tooltip: string;

    [key: string]: any;
}

export interface UserMatchExpression extends EntityExpression {
    userMatch: string;

    [key: string]: any;
}

export interface UserSelectionRenderOptions extends RenderOptions {
    noGroups: boolean;
    noUsers: boolean;

    [key: string]: any;
}

export interface ValueWithDeps {
    value: any | null;
    path: string | null;
    deps: string[] | null;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}